// =========================================================================
// TEST PROGRAM - Toate instructiunile implementate
// =========================================================================
// SP initial = 0x200 (512), stack creste in jos
// Memoria: 512 adrese (9 biti), adrese 0x000 - 0x1FF
// =========================================================================

// ==========================================================================
// SECTIUNEA 1: Test LDR, LDA_IMM, STR, STA_IMM (instructiuni de baza)
// ==========================================================================
0430    // 0x00: LDR X, #30         -> X = Mem[0x30] = 0x000A (10)
0631    // 0x01: LDR Y, #31         -> Y = Mem[0x31] = 0x0014 (20)
1432    // 0x02: LDA_IMM #32        -> AC = Mem[0x32] = 0x001E (30)

// ==========================================================================
// SECTIUNEA 2: Test PUSH/POP
// ==========================================================================
1C01    // 0x03: PUSH AC            -> Mem[0x1FF] = AC = 0x001E, SP = 0x1FE
1C02    // 0x04: PUSH X             -> Mem[0x1FE] = X = 0x000A, SP = 0x1FD
1C03    // 0x05: PUSH Y             -> Mem[0x1FD] = Y = 0x0014, SP = 0x1FC

0433    // 0x06: LDR X, #33         -> X = Mem[0x33] = 0xAAAA (schimba valori)
0634    // 0x07: LDR Y, #34         -> Y = Mem[0x34] = 0xBBBB
1435    // 0x08: LDA_IMM #35        -> AC = Mem[0x35] = 0xCCCC

2003    // 0x09: POP Y              -> SP = 0x1FD, Y = Mem[0x1FD] = 0x0014
2002    // 0x0A: POP X              -> SP = 0x1FE, X = Mem[0x1FE] = 0x000A
2001    // 0x0B: POP AC             -> SP = 0x1FF, AC = Mem[0x1FF] = 0x001E

// Store rezultate POP pentru verificare
0C40    // 0x0C: STR X, #40         -> Mem[0x40] = X = 0x000A
0E41    // 0x0D: STR Y, #41         -> Mem[0x41] = Y = 0x0014
1842    // 0x0E: STA_IMM #42        -> Mem[0x42] = AC = 0x001E

// ==========================================================================
// SECTIUNEA 3: Test JMP si RET
// ==========================================================================
// JMP salveaza PC+1 pe stack si sare la adresa
// RET restaureaza PC de pe stack

4820    // 0x0F: JMP 0x20           -> PUSH PC+1 (0x10), PC = 0x20 (subroutine)
        // Dupa RET, executia continua de la 0x10

// Dupa return din subroutine:
0C43    // 0x10: STR X, #43         -> Mem[0x43] = X = 0x0055 (setat in subroutine)
0E44    // 0x11: STR Y, #44         -> Mem[0x44] = Y = 0x00AA (setat in subroutine)

// ==========================================================================
// SECTIUNEA 4: Test BRA (branch always)
// ==========================================================================
4415    // 0x12: BRA 0x15           -> PC = 0x15 (sare peste 0x13, 0x14)

// Aceste instructiuni NU ar trebui executate (sarite de BRA)
0436    // 0x13: LDR X, #36         -> X = 0xDEAD (NU se executa)
0637    // 0x14: LDR Y, #37         -> Y = 0xBEEF (NU se executa)

// Continuare dupa BRA
1845    // 0x15: STA_IMM #45        -> Mem[0x45] = AC = 0x001E (verifica BRA a sarit)

// ==========================================================================
// SECTIUNEA 5: Test Conditional Branches (BNE, BEQ, etc.)
// ==========================================================================
// Nota: Flag-urile sunt probabil 0 dupa reset (Z=0, N=0, V=0, C=0)
// BNE (Z=0) ar trebui sa fie TAKEN
// BEQ (Z=1) ar trebui sa fie NOT TAKEN

3019    // 0x16: BNE 0x19           -> Z=0, deci branch TAKEN, PC = 0x19

// Aceste instructiuni NU ar trebui executate (sarite de BNE)
0436    // 0x17: LDR X, #36         -> X = 0xDEAD (NU se executa)
0637    // 0x18: LDR Y, #37         -> Y = 0xBEEF (NU se executa)

// Continuare dupa BNE
1846    // 0x19: STA_IMM #46        -> Mem[0x46] = AC (verifica BNE a sarit)

// Test BEQ - ar trebui sa NU fie luat (Z=0)
2C1C    // 0x1A: BEQ 0x1C           -> Z=0, deci branch NOT TAKEN, continua la 0x1B

1847    // 0x1B: STA_IMM #47        -> Mem[0x47] = AC (verifica BEQ NU a sarit)

// ==========================================================================
// SECTIUNEA 6: HLT
// ==========================================================================
0000    // 0x1C: HLT                -> Stop

// ==========================================================================
// PADDING (0x1D - 0x1F)
// ==========================================================================
0000    // 0x1D
0000    // 0x1E
0000    // 0x1F

// ==========================================================================
// SUBROUTINE la adresa 0x20 (apelata de JMP)
// ==========================================================================
0438    // 0x20: LDR X, #38         -> X = Mem[0x38] = 0x0055
0639    // 0x21: LDR Y, #39         -> Y = Mem[0x39] = 0x00AA
4C00    // 0x22: RET                -> POP PC, revine la 0x10

// ==========================================================================
// PADDING (0x23 - 0x2F)
// ==========================================================================
0000    // 0x23
0000    // 0x24
0000    // 0x25
0000    // 0x26
0000    // 0x27
0000    // 0x28
0000    // 0x29
0000    // 0x2A
0000    // 0x2B
0000    // 0x2C
0000    // 0x2D
0000    // 0x2E
0000    // 0x2F

// ==========================================================================
// DATA SECTION (0x30 - 0x4F)
// ==========================================================================
000A    // 0x30: valoare initiala X = 10
0014    // 0x31: valoare initiala Y = 20
001E    // 0x32: valoare initiala AC = 30
AAAA    // 0x33: valoare temporara X
BBBB    // 0x34: valoare temporara Y
CCCC    // 0x35: valoare temporara AC
DEAD    // 0x36: valoare "bad" X (nu ar trebui citita)
BEEF    // 0x37: valoare "bad" Y (nu ar trebui citita)
0055    // 0x38: valoare subroutine X
00AA    // 0x39: valoare subroutine Y
0000    // 0x3A
0000    // 0x3B
0000    // 0x3C
0000    // 0x3D
0000    // 0x3E
0000    // 0x3F

// Zona pentru rezultate verificare (0x40 - 0x4F)
0000    // 0x40: rezultat POP X
0000    // 0x41: rezultat POP Y
0000    // 0x42: rezultat POP AC
0000    // 0x43: rezultat subroutine X
0000    // 0x44: rezultat subroutine Y
0000    // 0x45: marker BRA executat
0000    // 0x46: marker BNE executat
0000    // 0x47: marker BEQ NOT taken
