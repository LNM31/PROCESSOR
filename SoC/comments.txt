0407 // 0000 0100 0000 0110 (X = Mem(address))
0A08 // 0000 1010 0000 0111  (ACC = Mem(Y + offset)) Y=0 
1409 // 0001 0100 0000 1000   (ACC = Mem(address))
0C0A // 0000 1100 0000 1001 (Mem(address) = X)
120B // 0001 0010 0000 1010  (Mem(Y + offset) = ACC)
180C // 0001 1000 0000 1011   (Mem(address) = ACC)


//2
040A // 0000 0100 0000 0110  X = Mem(address)
0A0B // 0000 1010 0000 0111  ACC = Mem(Y + offset) Y=0 
140C // 0001 0100 0000 1000  ACC = Mem(address)
0C0D // 0000 1100 0000 1001  Mem(address) = X
120E // 0001 0010 0000 1010  Mem(Y + offset) = ACC
060F // 0000 0110 0000 0110  Y = Mem(address)
1810 // 0001 1000 0000 1011  Mem(address) = ACC
0411 // 0000 0100 0000 0110  X = Mem(address)
0412 // 0000 0100 0000 0110  Y = Mem(address)
0C0D // 0000 1110 0000 1001  Mem(address) = Y
0000
1234
1235
1236
1237
1238
1239
1240
1241
1242
1243

//3
// =========================================================================
// TEST PROGRAM - PUSH, POP, INP, OUT + instructiuni de baza
// =========================================================================
// SP initial = 0x01FF (stack creste in jos)
// Format PUSH/POP/INP/OUT: opcode[15:10], imm[9:0]
// imm[9:4] = 000000, imm[3:0] = reg_code (0=PC, 1=AC, 2=X, 3=Y)
// =========================================================================

// --- SECTIUNEA 1: Incarca valori initiale ---
0430 // 0x00: LDR X, #30      -> X = Mem[30] = 0002
0631 // 0x01: LDR Y, #31      -> Y = Mem[31] = 0003
1432 // 0x02: LDA AC, #32     -> AC = Mem[32] = 1234

// --- SECTIUNEA 2: Test PUSH ---
1C01 // 0x03: PUSH AC         -> Mem[SP] = AC = 1234, SP--  (SP: 1FF->1FE)
1C02 // 0x04: PUSH X          -> Mem[SP] = X = 0002, SP--   (SP: 1FE->1FD)
1C03 // 0x05: PUSH Y          -> Mem[SP] = Y = 0003, SP--   (SP: 1FD->1FC)

// --- SECTIUNEA 3: Schimba valorile registrelor ---
0433 // 0x06: LDR X, #33      -> X = Mem[33] = AAAA (valoare noua)
0634 // 0x07: LDR Y, #34      -> Y = Mem[34] = BBBB (valoare noua)
1435 // 0x08: LDA AC, #35     -> AC = Mem[35] = CCCC (valoare noua)

// --- SECTIUNEA 4: Test POP (ordine inversa) ---
2003 // 0x09: POP Y           -> SP++, Y = Mem[SP] = 0003   (SP: 1FC->1FD)
2002 // 0x0A: POP X           -> SP++, X = Mem[SP] = 0002   (SP: 1FD->1FE)
2001 // 0x0B: POP AC          -> SP++, AC = Mem[SP] = 1234  (SP: 1FE->1FF)

// --- SECTIUNEA 5: Store pentru verificare POP ---
0C36 // 0x0C: STR X, #36      -> Mem[36] = X = 0002
0E37 // 0x0D: STR Y, #37      -> Mem[37] = Y = 0003
1838 // 0x0E: STA #38         -> Mem[38] = AC = 1234

// --- SECTIUNEA 6: Test INP/OUT ---
2401 // 0x0F: INP AC          -> AC = input de la tastatura
1839 // 0x10: STA #39         -> Mem[39] = AC (valoare citita)
2402 // 0x11: INP X           -> X = input de la tastatura
0C3A // 0x12: STR X, #3A      -> Mem[3A] = X (valoare citita)
2801 // 0x13: OUT AC          -> Afiseaza AC
2802 // 0x14: OUT X           -> Afiseaza X

// --- SECTIUNEA 7: HLT ---
0000 // 0x15: HLT             -> Stop

// --- PADDING ---
0000 // 0x16
0000 // 0x17
0000 // 0x18
0000 // 0x19
0000 // 0x1A
0000 // 0x1B
0000 // 0x1C
0000 // 0x1D
0000 // 0x1E
0000 // 0x1F
0000 // 0x20
0000 // 0x21
0000 // 0x22
0000 // 0x23
0000 // 0x24
0000 // 0x25
0000 // 0x26
0000 // 0x27
0000 // 0x28
0000 // 0x29
0000 // 0x2A
0000 // 0x2B
0000 // 0x2C
0000 // 0x2D
0000 // 0x2E
0000 // 0x2F

// --- DATA SECTION (0x30-0x3F) ---
0002 // 0x30: valoare initiala X
0003 // 0x31: valoare initiala Y
1234 // 0x32: valoare initiala AC
AAAA // 0x33: valoare noua X (dupa PUSH, inainte POP)
BBBB // 0x34: valoare noua Y (dupa PUSH, inainte POP)
CCCC // 0x35: valoare noua AC (dupa PUSH, inainte POP)
0000 // 0x36: pentru verificare X dupa POP
0000 // 0x37: pentru verificare Y dupa POP
0000 // 0x38: pentru verificare AC dupa POP
0000 // 0x39: pentru valoare INP AC
0000 // 0x3A: pentru valoare INP X

